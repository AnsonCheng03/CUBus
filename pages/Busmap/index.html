<html>

<head>
    <title>校巴地圖 School Bus Map | 中大校巴資訊站 CUHK BUS INFOPAGE</title>
    <meta charset="utf-8">
    <meta name="title" content="中大校巴資訊站 CUHK BUS INFOPAGE">
    <meta http-equiv="Content-Language" content="en,zh">
    <meta name="description"
        content="本頁為中大校園校巴地圖，可以圖像化方式查看校巴路線。The CUHK campus bus is depicted on this page's map. A graphical representation of the school bus' route is available.">
    <meta name="keywords"
        content="CUHK, 中大, 香港中文大學, The Chinese University of Hong Kong, BUS, CUBUS, 巴士, 校巴, School Bus, 路線, route, 校巴站, busstop">
    <meta name="robots" content="index, follow">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="revisit-after" content="7 days">
    <meta name="author" content="Anson Cheng">
    <link rel="icon" href="Images/bus.ico" type="image/x-icon">
    <link rel="shortcut icon" href="Images/bus.ico" type="image/x-icon">
    <meta name="viewport"
        content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height" />
    <meta name="MobileOptimized" content="320" />
    <meta name="google" content="notranslate">
    <meta name="google" value="notranslate">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KCD7N2ZG3H"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'G-KCD7N2ZG3H');
    </script>
    <script async="async" data-cfasync="false" src="//upgulpinon.com/1?z=5345133"></script>
    <script>
        !function () { "use strict"; !function () { class t { constructor(t) { this.id = -1, this.nativePointer = t, this.pageX = t.pageX, this.pageY = t.pageY, this.clientX = t.clientX, this.clientY = t.clientY, self.Touch && t instanceof Touch ? this.id = t.identifier : e(t) && (this.id = t.pointerId) } getCoalesced() { return "getCoalescedEvents" in this.nativePointer ? this.nativePointer.getCoalescedEvents().map(e => new t(e)) : [this] } } const e = t => self.PointerEvent && t instanceof PointerEvent, n = () => { }; class i { constructor(t, e) { this._element = t, this.startPointers = [], this.currentPointers = []; const { start: i = (() => !0), move: s = n, end: r = n } = e; this._startCallback = i, this._moveCallback = s, this._endCallback = r, this._pointerStart = this._pointerStart.bind(this), this._touchStart = this._touchStart.bind(this), this._move = this._move.bind(this), this._triggerPointerEnd = this._triggerPointerEnd.bind(this), this._pointerEnd = this._pointerEnd.bind(this), this._touchEnd = this._touchEnd.bind(this), self.PointerEvent ? this._element.addEventListener("pointerdown", this._pointerStart) : (this._element.addEventListener("mousedown", this._pointerStart), this._element.addEventListener("touchstart", this._touchStart), this._element.addEventListener("touchmove", this._move), this._element.addEventListener("touchend", this._touchEnd)) } _triggerPointerStart(t, e) { return !!this._startCallback(t, e) && (this.currentPointers.push(t), this.startPointers.push(t), !0) } _pointerStart(n) { 0 === n.button && this._triggerPointerStart(new t(n), n) && (e(n) ? (this._element.setPointerCapture(n.pointerId), this._element.addEventListener("pointermove", this._move), this._element.addEventListener("pointerup", this._pointerEnd)) : (window.addEventListener("mousemove", this._move), window.addEventListener("mouseup", this._pointerEnd))) } _touchStart(e) { for (const n of Array.from(e.changedTouches)) this._triggerPointerStart(new t(n), e) } _move(e) { const n = this.currentPointers.slice(), i = "changedTouches" in e ? Array.from(e.changedTouches).map(e => new t(e)) : [new t(e)], s = []; for (const t of i) { const e = this.currentPointers.findIndex(e => e.id === t.id); -1 !== e && (s.push(t), this.currentPointers[e] = t) } 0 !== s.length && this._moveCallback(n, s, e) } _triggerPointerEnd(t, e) { const n = this.currentPointers.findIndex(e => e.id === t.id); return -1 !== n && (this.currentPointers.splice(n, 1), this.startPointers.splice(n, 1), this._endCallback(t, e), !0) } _pointerEnd(n) { if (this._triggerPointerEnd(new t(n), n)) if (e(n)) { if (this.currentPointers.length) return; this._element.removeEventListener("pointermove", this._move), this._element.removeEventListener("pointerup", this._pointerEnd) } else window.removeEventListener("mousemove", this._move), window.removeEventListener("mouseup", this._pointerEnd) } _touchEnd(e) { for (const n of Array.from(e.changedTouches)) this._triggerPointerEnd(new t(n), e) } } !function (t, e) { void 0 === e && (e = {}); var n = e.insertAt; if (t && "undefined" != typeof document) { var i = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style"); s.type = "text/css", "top" === n && i.firstChild ? i.insertBefore(s, i.firstChild) : i.appendChild(s), s.styleSheet ? s.styleSheet.cssText = t : s.appendChild(document.createTextNode(t)) } }("pinch-zoom {\n  display: block;\n  overflow: hidden;\n  touch-action: none;\n  --scale: 1;\n  --x: 0;\n  --y: 0;\n}\n\npinch-zoom > * {\n  transform: translate(var(--x), var(--y)) scale(var(--scale));\n  transform-origin: 0 0;\n  will-change: transform;\n}\n"); const s = "min-scale"; function r(t, e) { return e ? Math.sqrt((e.clientX - t.clientX) ** 2 + (e.clientY - t.clientY) ** 2) : 0 } function o(t, e) { return e ? { clientX: (t.clientX + e.clientX) / 2, clientY: (t.clientY + e.clientY) / 2 } : t } function h(t, e) { return "number" == typeof t ? t : t.trimRight().endsWith("%") ? e * parseFloat(t) / 100 : parseFloat(t) } let a; function l() { return a || (a = document.createElementNS("http://www.w3.org/2000/svg", "svg")) } function c() { return l().createSVGMatrix() } function d() { return l().createSVGPoint() } const g = .01; class u extends HTMLElement { constructor() { super(), this._transform = c(), new MutationObserver(() => this._stageElChange()).observe(this, { childList: !0 }); const t = new i(this, { start: (e, n) => !(2 === t.currentPointers.length || !this._positioningEl) && (n.preventDefault(), !0), move: e => { this._onPointerMove(e, t.currentPointers) } }); this.addEventListener("wheel", t => this._onWheel(t)) } static get observedAttributes() { return [s] } attributeChangedCallback(t, e, n) { t === s && this.scale < this.minScale && this.setTransform({ scale: this.minScale }) } get minScale() { const t = this.getAttribute(s); if (!t) return g; const e = parseFloat(t); return Number.isFinite(e) ? Math.max(g, e) : g } set minScale(t) { this.setAttribute(s, String(t)) } connectedCallback() { this._stageElChange() } get x() { return this._transform.e } get y() { return this._transform.f } get scale() { return this._transform.a } scaleTo(t, e = {}) { let { originX: n = 0, originY: i = 0 } = e; const { relativeTo: s = "content", allowChangeEvent: r = !1 } = e, o = "content" === s ? this._positioningEl : this; if (!o || !this._positioningEl) return void this.setTransform({ scale: t, allowChangeEvent: r }); const a = o.getBoundingClientRect(); if (n = h(n, a.width), i = h(i, a.height), "content" === s) n += this.x, i += this.y; else { const t = this._positioningEl.getBoundingClientRect(); n -= t.left, i -= t.top } this._applyChange({ allowChangeEvent: r, originX: n, originY: i, scaleDiff: t / this.scale }) } setTransform(t = {}) { const { scale: e = this.scale, allowChangeEvent: n = !1 } = t; let { x: i = this.x, y: s = this.y } = t; if (!this._positioningEl) return void this._updateTransform(e, i, s, n); const r = this.getBoundingClientRect(), o = this._positioningEl.getBoundingClientRect(); if (!r.width || !r.height) return void this._updateTransform(e, i, s, n); let h = d(); h.x = o.left - r.left, h.y = o.top - r.top; let a = d(); a.x = o.width + h.x, a.y = o.height + h.y; const l = c().translate(i, s).scale(e).multiply(this._transform.inverse()); h = h.matrixTransform(l), a = a.matrixTransform(l), h.x > r.width ? i += r.width - h.x : a.x < 0 && (i += -a.x), h.y > r.height ? s += r.height - h.y : a.y < 0 && (s += -a.y), this._updateTransform(e, i, s, n) } _updateTransform(t, e, n, i) { if (!(t < this.minScale) && (t !== this.scale || e !== this.x || n !== this.y) && (this._transform.e = e, this._transform.f = n, this._transform.d = this._transform.a = t, this.style.setProperty("--x", this.x + "px"), this.style.setProperty("--y", this.y + "px"), this.style.setProperty("--scale", this.scale + ""), i)) { const t = new Event("change", { bubbles: !0 }); this.dispatchEvent(t) } } _stageElChange() { this._positioningEl = void 0, 0 !== this.children.length && (this._positioningEl = this.children[0], this.children.length > 1 && console.warn("<pinch-zoom> must not have more than one child."), this.setTransform({ allowChangeEvent: !0 })) } _onWheel(t) { if (!this._positioningEl) return; t.preventDefault(); const e = this._positioningEl.getBoundingClientRect(); let { deltaY: n } = t; const { ctrlKey: i, deltaMode: s } = t; 1 === s && (n *= 15); const r = 1 - n / (i ? 100 : 300); this._applyChange({ scaleDiff: r, originX: t.clientX - e.left, originY: t.clientY - e.top, allowChangeEvent: !0 }) } _onPointerMove(t, e) { if (!this._positioningEl) return; const n = this._positioningEl.getBoundingClientRect(), i = o(t[0], t[1]), s = o(e[0], e[1]), h = i.clientX - n.left, a = i.clientY - n.top, l = r(t[0], t[1]), c = r(e[0], e[1]), d = l ? c / l : 1; this._applyChange({ originX: h, originY: a, scaleDiff: d, panX: s.clientX - i.clientX, panY: s.clientY - i.clientY, allowChangeEvent: !0 }) } _applyChange(t = {}) { const { panX: e = 0, panY: n = 0, originX: i = 0, originY: s = 0, scaleDiff: r = 1, allowChangeEvent: o = !1 } = t, h = c().translate(e, n).translate(i, s).translate(this.x, this.y).scale(r).translate(-i, -s).scale(this.scale); this.setTransform({ allowChangeEvent: o, scale: h.a, x: h.e, y: h.f }) } } customElements.define("pinch-zoom", u) }() }();
    </script>
    <style>
        body {
            margin: 0;
            font-family: Arial, Helvetica, sans-serif;
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        header {
            position: fixed;
            left: 5vw;
            top: 5vh;
            z-index: 1000;

            text-align: center;
            padding: 10px 30px 30px 30px;
            border-radius: 20px;
            box-shadow: 0 5px 10px rgba(154, 160, 185, .05), 0 15px 40px rgba(166, 173, 201, .2);
            background-color: #fff;
            width: fit-content;
        }

        header h1 {
            text-align: center;
            font-size: 1.5rem;
        }

        header a {
            border-radius: 10px;
            background: #62529c;
            color: #fff;
            padding: 10px;
            text-decoration: none;
        }

        pinch-zoom {
            max-width: 100vw;
            max-height: 100vh;
            overflow: scroll;
        }

        pinch-zoom img {
            height: 500vh;
        }
    </style>
</head>

<body>
    <header>
        <h1>地圖 Map</h1>
        <a href="/">Back 返回</a>
    </header>

    <pinch-zoom>
        <img src="/Images/schoolbusmap.svg" alt="School Bus Map">
        </img>
    </pinch-zoom>
    <script>
        const pinchZoom = document.querySelector('pinch-zoom');
        pinchZoom.setTransform({
            scale: 0.25,
        });
    </script>
</body>

</html>